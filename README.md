# Tree
树的各种结构及其实现，应用，解决方案


1，二分搜索树的实现
	（1）add  contains  前序，中序，后序遍历
	打印出树的结构
	
2，线段树的实现
    //线段树区间
    private E[] data;
    //用数组表示线段树
    private E[] tree;
    private Merger<E> merger;
2.1，创建线段树
	/**
     * 在treeIndex的位置，创建表示区间[l...r]的线段树
     *
     * @param treeIndex 要创建线段树的根节点所对应的索引
     * @param l         创建线段的左区间
     * @param r         创建线段的右区间
     */
    private void buildSegmentTree(int treeIndex, int l, int r) 
query和set操作

3，trie字典树
//当前这个节点，是否是某一个单词
        boolean isWord;

        //每一个节点有若干个指向下个节点的指针，next就是字符和Node的映射
        TreeMap<Character, Node> next;

 //查询是否在Trie中存在有单词以prefix为前缀
    public boolean isPrefix(String prefix) 
 
   //和添加很相似，都需要遍历，不同的是，如果遍历到节点不包括某个字符，直接返回false即可，
    public boolean contains(String word)
    
    
    add操作
    
    
 AVL树是根据它的发明者G.M. Adelson-Velsky和E.M. Landis命名的。
它是最先发明的自平衡二叉查找树，也被称为高度平衡树。相比于"二叉查找树"，它的特点是：AVL树中任何节点的两个子树的高度最大差别为1

AVL树的查找、插入和删除在平均和最坏情况下都是O(logn)。
如果在AVL树中插入或删除节点后，使得高度之差大于1。此时，AVL树的平衡状态就被破坏，它就不再是一棵二叉树；为了让它重新维持在一个平衡状态，就需要对其进行旋转处理。学AVL树，重点的地方也就是它的旋转算法


红黑树：
二叉查找树是在生成的时候是非常容易失衡的，造成的最坏情况就是一边倒（即只有左子树/右子树），这样会导致树检索的效率大大降低。（关于树和二叉查找树可以看我之前写的一篇文章树型结构）

红黑树是为了维护二叉查找树的平衡而产生的一种树，根据维基百科的定义，红黑树有五个特性，但我觉得讲得不太易懂，我自己总结一下，红黑树的特性大致有三个（换句话说，插入、删除节点后整个红黑树也必须满足下面的三个性质，如果不满足则必须进行旋转）：

根节点与叶节点都是黑色节点，其中叶节点为Null节点
每个红色节点的两个子节点都是黑色节点，换句话说就是不能有连续两个红色节点
从根节点到所有叶子节点上的黑色节点数量是相同的
上述的性质约束了红黑树的关键：从根到叶子的最长可能路径不多于最短可能路径的两倍长。得到这个结论的理由是：

红黑树中最短的可能路径是全部为黑色节点的路径
红黑树中最长的可能路径是红黑相间的路径
此时（2）正好是（1）的两倍长。结果就是这个树大致上是平衡的，因为比如插入、删除和查找某个值这样的操作最坏情况都要求与树的高度成比例，这个高度的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树，最终保证了红黑树能够以O(log2 n) 的时间复杂度进行搜索、插入、删除
红黑树并不是高度平衡的，它放弃了高度平衡的特性而只追求部分平衡，这种特性降低了插入、删除时对树旋转的要求，从而提升了树的整体性能。而其他平衡树比如AVL树虽然查找性能为性能是O(logn)，但是为了维护其平衡特性，可能要在插入、删除操作时进行多次的旋转，产生比较大的消耗。
